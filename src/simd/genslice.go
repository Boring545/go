// Copyright 2025 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build ignore

package main

// this generates all the code to load and store simd
// vectors to/from slices.

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"os"
	"strings"
)

// //go:noescape
// func LoadUint8x16Slice(s []uint8) Uint8x16 {
// 	return LoadUint8x16((*[16]uint8)(s[:16]))
// }

// //go:noescape
// func (x Uint8x16) StoreSlice(s []uint8) {
//    x.Store((*[16]uint8)(s[:16]))
// }

func slice(e string, w, c int, out io.Writer) {
	b := w * c
	if b < 128 || b > 512 {
		return
	}
	E := strings.ToUpper(e[:1]) + e[1:]
	t := fmt.Sprintf("%s%d", e, w)
	v := fmt.Sprintf("%s%dx%d", E, w, c)
	a := "a"
	if strings.Contains("aeiou", e[:1]) {
		a = "an"
	}
	fmt.Fprintf(out,
		`
// Load%sSlice loads %s %s from a slice of at least %d %ss
func Load%sSlice(s []%s) %s {
	return Load%s((*[%d]%s)(s))
}
`, v, a, v, c, t, v, t, v, v, c, t)

	fmt.Fprintf(out,
		`
// StoreSlice stores x into a slice of at least %d %ss
func (x %s) StoreSlice(s []%s) {
   x.Store((*[%d]%s)(s))
}
`, c, t, v, t, c, t)

}

func prologue(s string, out io.Writer) {
	fmt.Fprintf(out,
		`// Code generated by '%s'; DO NOT EDIT.

//go:build goexperiment.simd

// The build condition == if the experiment is not on, cmd/api TestCheck will see this and complain
// see also go/doc/comment, where "simd" is inserted to the package list of the experiment is not on.

package simd

`, s)
}

func main() {
	filename := flag.String("o", "", "write generated code to this file")
	flag.Parse()

	ofile := os.Stdout

	if *filename != "" {
		var err error
		ofile, err = os.Create(*filename)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Could not create the output file for the generated code, %v", err)
			os.Exit(1)
		}
	}

	out := new(bytes.Buffer)

	prologue("go run genslice.go -o slice_amd64.go", out)

	vecs := []int{128, 256, 512}
	ints := []int{8, 16, 32, 64}
	floats := []int{32, 64}
	for _, v := range vecs {
		for _, w := range ints {
			c := v / w
			slice("int", w, c, out)
			slice("uint", w, c, out)
		}
		for _, w := range floats {
			c := v / w
			slice("float", w, c, out)
		}
	}
	b, err := format.Source(out.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "There was a problem formatting the generated code, %v", err)
		os.Exit(1)
	} else {
		ofile.Write(b)
		ofile.Close()
	}
}
